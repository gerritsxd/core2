<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Problematic Hypersexuality – COMMS Repository Template: CoRe</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-9445a4555af3a56b987823823f9b9d54.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">COMMS Repository Template: CoRe</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../repo/index.html"> 
<span class="menu-text">Overview</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../posts/index.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#definition" id="toc-definition" class="nav-link active" data-scroll-target="#definition">Definition</a></li>
  <li><a href="#developing-measurement-instruments" id="toc-developing-measurement-instruments" class="nav-link" data-scroll-target="#developing-measurement-instruments">Developing Measurement Instruments</a></li>
  <li><a href="#coding-measurement-instruments" id="toc-coding-measurement-instruments" class="nav-link" data-scroll-target="#coding-measurement-instruments">Coding Measurement Instruments</a></li>
  <li><a href="#eliciting-construct-content-qualitative-research" id="toc-eliciting-construct-content-qualitative-research" class="nav-link" data-scroll-target="#eliciting-construct-content-qualitative-research">Eliciting Construct Content (Qualitative Research)</a></li>
  <li><a href="#coding-qualitative-data" id="toc-coding-qualitative-data" class="nav-link" data-scroll-target="#coding-qualitative-data">Coding Qualitative Data</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Problematic Hypersexuality</h1>
<p class="subtitle lead">UCID: problematicHypersexuality_7mm4hr4f</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="definition" class="level2">
<h2 class="anchored" data-anchor-id="definition">Definition</h2>
<p>Problematic Hypersexuality (PH) is defined as the experience of distress and negative consequences due to hypersexual urges and behavior - to the extent that the experience of PH causes the individual to at least consider seeking help. The construct of PH we base on the common and unique criteria (ten in total) found in three perspectives on PH.</p>
<p>—- Before we present these ten criteria we distilled from the three perspectives, we note that the three perspectives come as diagnostic systems, while our definition of PH must be taken as a construct definition for research. This means, among others, that what are called ‘criteria’ within the diagnostic systems, we call ‘characteristics’. With this Decentralized Construct Taxonomy (DCT) definition on PH we hope to define as clearly as possible what we mean by PH in our studies (references to the studies using this definition can be found under ‘Comments’). As our research progresses, the DCT definition of PH might change. Also, others might use other but similar constructs that can be equally valid, if made explicit. Current research practices often suffer from hidden heterogeneity: definitions are not made explicit or are imprecise. Often constructs that bear the same name, prove to differ in small but important details. Reasons to adhere to explicit heterogeneity in definitions of constructs are explained in more detail here: (Peters &amp; Crutzen, 2022, https://doi.org/10.31234/osf.io/8tpcv).</p>
<p>—- We now return to the DCT definition of PH. The three diagnostic perspectives on PH we make use of, are: 1) Sex addiction; 2) Hypersexual Disorder; and 3) Compulsive Sexual Behavior Disorder. The ten characteristics of PH we apply in this DCT of PH are based on 6 overlapping criteria and 4 unique criteria for PH retrieved from these three perspectives. The 6 overlapping criteria for PH we retrieved, are: 1) Intense focus on and preoccupation with sex; 2) Repetitive sexual acitivities leading to neglect of selfcare and responsibilities; 3) Negative consequences in one or more life domains; 4) Disregard of risk of harm to self or others: 5) Failed attempts to stop the sexual behavior; and 6) Continue PH behavior despite negative consequences. From the ‘sex addiction’ perspective we retrieved the following criteria: 7) Tolerance (the need to increase sexual intenstiy of frequency); and 8) Withdrawal symptoms (e.g.&nbsp;restlessness). From the ‘hypersexual disorder’ perspective we retrieved: 9) Sex used to cope with dysphoric mood states or stressful life events. From the ‘compulsive sexual behavior disorder’ perspective we retrieved: 10) Continue PH behavior despite loss of pleasure in sex. These ten potentially cue valid characteristics of PH we consider as more permanent and relatively stable. With cue valid we mean: to a greater or lesser degree uniquely pertaining to hypersexuality. IRT validation studies can decide on the importance of each of these characteristics in assessing PH and are able to assess cue validity when relevant subpopulations are included in research. Furthermore, we consider PH to be ruled by two drivers: 1) high sexual desire; and 2) emotion dysregulation with regard to sexuality (Kingston, 2018; specifies these drivers as ‘dimensions’). These two drivers we see as necessary for PH to occur but not as sufficient for PH to be the case. The ten characteristics are connected to the two drivers as outcomes are connected to processes. The process in PH that is maintained by the two drivers is that of a vicious circle- we hypothesize. Negative feelings (e.g.&nbsp;shame) lead to sexually acting out in order to cope with them. The sexual acting out reinforces shame, thus increasing the risk of a new cycle of shame and sexual acting out. Our investigations of this vicious circle is underway but at the time not conclusive. Therefore, this DCT of PH should be considered as preliminary and open to change. If a vicious circle for PH is not confirmed - or even disconfirmed - this will lead to a different DCT for PH. If a vicious circle is confirmed, this might lead to a more detailed description of its nature, and this too will lead to an adaptation of this DCT for PH.</p>
<p>—- To conclude this definition: we consider Problematic Hypersexuality as delineated from Non-problematic Hypersexuality (NH). By NH we mean the experience of hypersexuality without enduring distress or negative consequences. Hypersexuality in general - in short defined as taking great interest in experiencing sexuality - is the overarching concept, binding NH and PH together. In the future both NH and Hypersexuality might be awarded their own DCT.</p>
<p>—- We offer the following figure as an overview of this DCT definition of PH and note that cue valid characteristics are best established using IRT validation, while measuring driving processes of PH can best be done using ESM techniques: https://osf.io/89ha7 Both research methodologies (IRT and ESM) will profit from comparing a PH populations with relevant other populations and we suggest to consider an NH population for this purpose.</p>
<p>—–Studies using this DCT of PH are currently under review or are being developed (January 2023).</p>
<p>—-References:</p>
<p>—-Kingston D. A. (2018). Hypersexuality: Fact or Fiction?. The journal of sexual medicine, 15(5), 613–615. https://doi.org/10.1016/j.jsxm.2018.02.015</p>
<p>—-Peters, G. Y., &amp; Crutzen, R. (2022, November 22). Knowing What We’re Talking About: Facilitating Decentralized, Unequivocal Publication of and Reference to Psychological Construct Definitions and Instructions. https://doi.org/10.31234/osf.io/8tpcv</p>
<p>—-Wolf, M. G., Ihm, E. D., maul, a., &amp; Taves, A. (2019, July 23). Survey Item Validation. https://doi.org/10.31234/osf.io/k27w3</p>
</section>
<section id="developing-measurement-instruments" class="level2">
<h2 class="anchored" data-anchor-id="developing-measurement-instruments">Developing Measurement Instruments</h2>
<ol type="1">
<li><p>One-off measurement instruments - Currently, there are a number of one-off measurement instruments available that either measure sex addiction, hypersexual disorder or compulsive sexual behavior disorder. These questionnaires reflect one specific perspective on PH. In line with our DCT definition for PH, we intend to combine a number of these questionnaires into one instrument. For this we need to investigate which items predict best if someone is afflicted by PH. This study is now (January 2023) underway. Previous validation research for PH did not involve Item Response Theory techniques. We make use of IRT to make the best selection of cue valid items from the different measurement instruments for PH. These items and instruments have been developed within the three perspectives on PH (sex addiction, hypersexual disorder, compulsive sexual behavior disorder). IRT might help to decide on what characteristics best define PH.</p></li>
<li><p>Dynamical assessment - As specified in the definition, we see PH as driven by high sexual desire in combination with emotion dysregulation. These dynamical and fluctuating processes involved in PH we see as underlying the more permanent outcomes (each of the ten characteristics of PH). Experience Sampling Method (ESM) techniques are most optimal to assess these processes, as ESM is an ecologically valid method that is capable to assess fluctuations in sexual desire and emotions and link these to sexual activity in temporal analyses. Currently, a number of items are involved in measuring sexual desire and emotions with ESM techniques. Response Process Evaluations (Wolf et al., 2019) of these items needs to be undertaken still.</p></li>
</ol>
</section>
<section id="coding-measurement-instruments" class="level2">
<h2 class="anchored" data-anchor-id="coding-measurement-instruments">Coding Measurement Instruments</h2>
<p>For literature reviews no instructions for coding measurement instruments are given as this construct definition of PH is new. It might be investigated in a literature review as either sexual addiction, hypersexual disorder or compulsive sexual behavior disorde. All three perspectives shed light on a particular aspect of PH. Therefore, at this moment, a literature review on PH should rather consider the three perspectives on PH separately or in combination, to investigate previous studies on subjects related to PH.</p>
</section>
<section id="eliciting-construct-content-qualitative-research" class="level2">
<h2 class="anchored" data-anchor-id="eliciting-construct-content-qualitative-research">Eliciting Construct Content (Qualitative Research)</h2>
<p>For different subpopulations instructions to elicit content will be different. In a qualitative study on chemsex participation, currently being developed, we will elicit construct content using the following coding structure https://osf.io/s843n</p>
<p>We note that the vicious circle hypothesized for PH in general - as described in this DCT definition for PH - is an integral part of the coding structure. For other groups (e.g.&nbsp;NH and PH pornusers), a similar coding structure for PH (in presented in blue block) will be used, also including a vicious circle. However, the overall structure will be different, as pornuse and chemsex generally take place in very different settings (and this setting or context is part of the coding structure as well, as is exemplified in the a priori coding structure for the chemsex study).</p>
</section>
<section id="coding-qualitative-data" class="level2">
<h2 class="anchored" data-anchor-id="coding-qualitative-data">Coding Qualitative Data</h2>
<p>Construct content will be coded at first as separate themes, following the a priori coding structure for PH chemsex participation (in case of the chemsex study). This coding scheme already provides a potential network structure in which certain aspects of chemsex experiences can be more prominently linked to characteristics of PH than others. Such connections will be subsumed under new themes by axial coding. Then, attention can be given to the more prominently visible and nuanced aspects by assigning childcodes to them.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/gerritsxd\.github\.io\/repo2\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>